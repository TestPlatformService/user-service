// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.12.4
// source: question.proto

package question

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	QuestionService_CreateQuestion_FullMethodName      = "/question.QuestionService/CreateQuestion"
	QuestionService_GetQuestion_FullMethodName         = "/question.QuestionService/GetQuestion"
	QuestionService_GetAllQuestions_FullMethodName     = "/question.QuestionService/GetAllQuestions"
	QuestionService_UpdateQuestion_FullMethodName      = "/question.QuestionService/UpdateQuestion"
	QuestionService_DeleteQuestion_FullMethodName      = "/question.QuestionService/DeleteQuestion"
	QuestionService_UploadImageQuestion_FullMethodName = "/question.QuestionService/UploadImageQuestion"
	QuestionService_DeleteImageQuestion_FullMethodName = "/question.QuestionService/DeleteImageQuestion"
	QuestionService_IsQuestionExist_FullMethodName     = "/question.QuestionService/IsQuestionExist"
)

// QuestionServiceClient is the client API for QuestionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionServiceClient interface {
	// question
	CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*QuestionId, error)
	GetQuestion(ctx context.Context, in *QuestionId, opts ...grpc.CallOption) (*GetQuestionResponse, error)
	GetAllQuestions(ctx context.Context, in *GetAllQuestionsRequest, opts ...grpc.CallOption) (*GetAllQuestionsResponse, error)
	UpdateQuestion(ctx context.Context, in *UpdateQuestionRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*Void, error)
	UploadImageQuestion(ctx context.Context, in *UploadImageQuestionRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteImageQuestion(ctx context.Context, in *DeleteImageQuestionRequest, opts ...grpc.CallOption) (*Void, error)
	IsQuestionExist(ctx context.Context, in *QuestionId, opts ...grpc.CallOption) (*Void, error)
}

type questionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionServiceClient(cc grpc.ClientConnInterface) QuestionServiceClient {
	return &questionServiceClient{cc}
}

func (c *questionServiceClient) CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*QuestionId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuestionId)
	err := c.cc.Invoke(ctx, QuestionService_CreateQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetQuestion(ctx context.Context, in *QuestionId, opts ...grpc.CallOption) (*GetQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetAllQuestions(ctx context.Context, in *GetAllQuestionsRequest, opts ...grpc.CallOption) (*GetAllQuestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllQuestionsResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetAllQuestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) UpdateQuestion(ctx context.Context, in *UpdateQuestionRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, QuestionService_UpdateQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, QuestionService_DeleteQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) UploadImageQuestion(ctx context.Context, in *UploadImageQuestionRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, QuestionService_UploadImageQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) DeleteImageQuestion(ctx context.Context, in *DeleteImageQuestionRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, QuestionService_DeleteImageQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) IsQuestionExist(ctx context.Context, in *QuestionId, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, QuestionService_IsQuestionExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionServiceServer is the server API for QuestionService service.
// All implementations must embed UnimplementedQuestionServiceServer
// for forward compatibility
type QuestionServiceServer interface {
	// question
	CreateQuestion(context.Context, *CreateQuestionRequest) (*QuestionId, error)
	GetQuestion(context.Context, *QuestionId) (*GetQuestionResponse, error)
	GetAllQuestions(context.Context, *GetAllQuestionsRequest) (*GetAllQuestionsResponse, error)
	UpdateQuestion(context.Context, *UpdateQuestionRequest) (*Void, error)
	DeleteQuestion(context.Context, *DeleteQuestionRequest) (*Void, error)
	UploadImageQuestion(context.Context, *UploadImageQuestionRequest) (*Void, error)
	DeleteImageQuestion(context.Context, *DeleteImageQuestionRequest) (*Void, error)
	IsQuestionExist(context.Context, *QuestionId) (*Void, error)
	mustEmbedUnimplementedQuestionServiceServer()
}

// UnimplementedQuestionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedQuestionServiceServer struct {
}

func (UnimplementedQuestionServiceServer) CreateQuestion(context.Context, *CreateQuestionRequest) (*QuestionId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) GetQuestion(context.Context, *QuestionId) (*GetQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) GetAllQuestions(context.Context, *GetAllQuestionsRequest) (*GetAllQuestionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllQuestions not implemented")
}
func (UnimplementedQuestionServiceServer) UpdateQuestion(context.Context, *UpdateQuestionRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) DeleteQuestion(context.Context, *DeleteQuestionRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) UploadImageQuestion(context.Context, *UploadImageQuestionRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadImageQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) DeleteImageQuestion(context.Context, *DeleteImageQuestionRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImageQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) IsQuestionExist(context.Context, *QuestionId) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsQuestionExist not implemented")
}
func (UnimplementedQuestionServiceServer) mustEmbedUnimplementedQuestionServiceServer() {}

// UnsafeQuestionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionServiceServer will
// result in compilation errors.
type UnsafeQuestionServiceServer interface {
	mustEmbedUnimplementedQuestionServiceServer()
}

func RegisterQuestionServiceServer(s grpc.ServiceRegistrar, srv QuestionServiceServer) {
	s.RegisterService(&QuestionService_ServiceDesc, srv)
}

func _QuestionService_CreateQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CreateQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, req.(*CreateQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuestionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetQuestion(ctx, req.(*QuestionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetAllQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllQuestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetAllQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetAllQuestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetAllQuestions(ctx, req.(*GetAllQuestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_UpdateQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).UpdateQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_UpdateQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).UpdateQuestion(ctx, req.(*UpdateQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_DeleteQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_DeleteQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, req.(*DeleteQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_UploadImageQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadImageQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).UploadImageQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_UploadImageQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).UploadImageQuestion(ctx, req.(*UploadImageQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_DeleteImageQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).DeleteImageQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_DeleteImageQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).DeleteImageQuestion(ctx, req.(*DeleteImageQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_IsQuestionExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuestionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).IsQuestionExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_IsQuestionExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).IsQuestionExist(ctx, req.(*QuestionId))
	}
	return interceptor(ctx, in, info, handler)
}

// QuestionService_ServiceDesc is the grpc.ServiceDesc for QuestionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QuestionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "question.QuestionService",
	HandlerType: (*QuestionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQuestion",
			Handler:    _QuestionService_CreateQuestion_Handler,
		},
		{
			MethodName: "GetQuestion",
			Handler:    _QuestionService_GetQuestion_Handler,
		},
		{
			MethodName: "GetAllQuestions",
			Handler:    _QuestionService_GetAllQuestions_Handler,
		},
		{
			MethodName: "UpdateQuestion",
			Handler:    _QuestionService_UpdateQuestion_Handler,
		},
		{
			MethodName: "DeleteQuestion",
			Handler:    _QuestionService_DeleteQuestion_Handler,
		},
		{
			MethodName: "UploadImageQuestion",
			Handler:    _QuestionService_UploadImageQuestion_Handler,
		},
		{
			MethodName: "DeleteImageQuestion",
			Handler:    _QuestionService_DeleteImageQuestion_Handler,
		},
		{
			MethodName: "IsQuestionExist",
			Handler:    _QuestionService_IsQuestionExist_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "question.proto",
}

const (
	OutputService_CreateQuestionOutput_FullMethodName              = "/question.OutputService/CreateQuestionOutput"
	OutputService_GetQuestionOutput_FullMethodName                 = "/question.OutputService/GetQuestionOutput"
	OutputService_GetAllQuestionOutputsByQuestionId_FullMethodName = "/question.OutputService/GetAllQuestionOutputsByQuestionId"
	OutputService_UpdateQuestionOutput_FullMethodName              = "/question.OutputService/UpdateQuestionOutput"
	OutputService_DeleteQuestionOutput_FullMethodName              = "/question.OutputService/DeleteQuestionOutput"
)

// OutputServiceClient is the client API for OutputService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// output
type OutputServiceClient interface {
	CreateQuestionOutput(ctx context.Context, in *CreateQuestionOutputRequest, opts ...grpc.CallOption) (*QuestionOutputId, error)
	GetQuestionOutput(ctx context.Context, in *QuestionOutputId, opts ...grpc.CallOption) (*GetQuestionOutputResponse, error)
	GetAllQuestionOutputsByQuestionId(ctx context.Context, in *GetAllQuestionOutputsByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllQuestionOutputsByQuestionIdResponse, error)
	UpdateQuestionOutput(ctx context.Context, in *UpdateQuestionOutputRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteQuestionOutput(ctx context.Context, in *DeleteQuestionOutputRequest, opts ...grpc.CallOption) (*Void, error)
}

type outputServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOutputServiceClient(cc grpc.ClientConnInterface) OutputServiceClient {
	return &outputServiceClient{cc}
}

func (c *outputServiceClient) CreateQuestionOutput(ctx context.Context, in *CreateQuestionOutputRequest, opts ...grpc.CallOption) (*QuestionOutputId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuestionOutputId)
	err := c.cc.Invoke(ctx, OutputService_CreateQuestionOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputServiceClient) GetQuestionOutput(ctx context.Context, in *QuestionOutputId, opts ...grpc.CallOption) (*GetQuestionOutputResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionOutputResponse)
	err := c.cc.Invoke(ctx, OutputService_GetQuestionOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputServiceClient) GetAllQuestionOutputsByQuestionId(ctx context.Context, in *GetAllQuestionOutputsByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllQuestionOutputsByQuestionIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllQuestionOutputsByQuestionIdResponse)
	err := c.cc.Invoke(ctx, OutputService_GetAllQuestionOutputsByQuestionId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputServiceClient) UpdateQuestionOutput(ctx context.Context, in *UpdateQuestionOutputRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, OutputService_UpdateQuestionOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputServiceClient) DeleteQuestionOutput(ctx context.Context, in *DeleteQuestionOutputRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, OutputService_DeleteQuestionOutput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OutputServiceServer is the server API for OutputService service.
// All implementations must embed UnimplementedOutputServiceServer
// for forward compatibility
//
// output
type OutputServiceServer interface {
	CreateQuestionOutput(context.Context, *CreateQuestionOutputRequest) (*QuestionOutputId, error)
	GetQuestionOutput(context.Context, *QuestionOutputId) (*GetQuestionOutputResponse, error)
	GetAllQuestionOutputsByQuestionId(context.Context, *GetAllQuestionOutputsByQuestionIdRequest) (*GetAllQuestionOutputsByQuestionIdResponse, error)
	UpdateQuestionOutput(context.Context, *UpdateQuestionOutputRequest) (*Void, error)
	DeleteQuestionOutput(context.Context, *DeleteQuestionOutputRequest) (*Void, error)
	mustEmbedUnimplementedOutputServiceServer()
}

// UnimplementedOutputServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOutputServiceServer struct {
}

func (UnimplementedOutputServiceServer) CreateQuestionOutput(context.Context, *CreateQuestionOutputRequest) (*QuestionOutputId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestionOutput not implemented")
}
func (UnimplementedOutputServiceServer) GetQuestionOutput(context.Context, *QuestionOutputId) (*GetQuestionOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionOutput not implemented")
}
func (UnimplementedOutputServiceServer) GetAllQuestionOutputsByQuestionId(context.Context, *GetAllQuestionOutputsByQuestionIdRequest) (*GetAllQuestionOutputsByQuestionIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllQuestionOutputsByQuestionId not implemented")
}
func (UnimplementedOutputServiceServer) UpdateQuestionOutput(context.Context, *UpdateQuestionOutputRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQuestionOutput not implemented")
}
func (UnimplementedOutputServiceServer) DeleteQuestionOutput(context.Context, *DeleteQuestionOutputRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestionOutput not implemented")
}
func (UnimplementedOutputServiceServer) mustEmbedUnimplementedOutputServiceServer() {}

// UnsafeOutputServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OutputServiceServer will
// result in compilation errors.
type UnsafeOutputServiceServer interface {
	mustEmbedUnimplementedOutputServiceServer()
}

func RegisterOutputServiceServer(s grpc.ServiceRegistrar, srv OutputServiceServer) {
	s.RegisterService(&OutputService_ServiceDesc, srv)
}

func _OutputService_CreateQuestionOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServiceServer).CreateQuestionOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OutputService_CreateQuestionOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServiceServer).CreateQuestionOutput(ctx, req.(*CreateQuestionOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OutputService_GetQuestionOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuestionOutputId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServiceServer).GetQuestionOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OutputService_GetQuestionOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServiceServer).GetQuestionOutput(ctx, req.(*QuestionOutputId))
	}
	return interceptor(ctx, in, info, handler)
}

func _OutputService_GetAllQuestionOutputsByQuestionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllQuestionOutputsByQuestionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServiceServer).GetAllQuestionOutputsByQuestionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OutputService_GetAllQuestionOutputsByQuestionId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServiceServer).GetAllQuestionOutputsByQuestionId(ctx, req.(*GetAllQuestionOutputsByQuestionIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OutputService_UpdateQuestionOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQuestionOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServiceServer).UpdateQuestionOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OutputService_UpdateQuestionOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServiceServer).UpdateQuestionOutput(ctx, req.(*UpdateQuestionOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OutputService_DeleteQuestionOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServiceServer).DeleteQuestionOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OutputService_DeleteQuestionOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServiceServer).DeleteQuestionOutput(ctx, req.(*DeleteQuestionOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OutputService_ServiceDesc is the grpc.ServiceDesc for OutputService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OutputService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "question.OutputService",
	HandlerType: (*OutputServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQuestionOutput",
			Handler:    _OutputService_CreateQuestionOutput_Handler,
		},
		{
			MethodName: "GetQuestionOutput",
			Handler:    _OutputService_GetQuestionOutput_Handler,
		},
		{
			MethodName: "GetAllQuestionOutputsByQuestionId",
			Handler:    _OutputService_GetAllQuestionOutputsByQuestionId_Handler,
		},
		{
			MethodName: "UpdateQuestionOutput",
			Handler:    _OutputService_UpdateQuestionOutput_Handler,
		},
		{
			MethodName: "DeleteQuestionOutput",
			Handler:    _OutputService_DeleteQuestionOutput_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "question.proto",
}

const (
	InputService_CreateQuestionInput_FullMethodName              = "/question.InputService/CreateQuestionInput"
	InputService_GetQuestionInput_FullMethodName                 = "/question.InputService/GetQuestionInput"
	InputService_GetAllQuestionInputsByQuestionId_FullMethodName = "/question.InputService/GetAllQuestionInputsByQuestionId"
	InputService_UpdateQuestionInput_FullMethodName              = "/question.InputService/UpdateQuestionInput"
	InputService_DeleteQuestionInput_FullMethodName              = "/question.InputService/DeleteQuestionInput"
)

// InputServiceClient is the client API for InputService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// input
type InputServiceClient interface {
	CreateQuestionInput(ctx context.Context, in *CreateQuestionInputRequest, opts ...grpc.CallOption) (*QuestionInputId, error)
	GetQuestionInput(ctx context.Context, in *QuestionInputId, opts ...grpc.CallOption) (*GetQuestionInputResponse, error)
	GetAllQuestionInputsByQuestionId(ctx context.Context, in *GetAllQuestionInputsByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllQuestionInputsByQuestionIdResponse, error)
	UpdateQuestionInput(ctx context.Context, in *UpdateQuestionInputRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteQuestionInput(ctx context.Context, in *DeleteQuestionInputRequest, opts ...grpc.CallOption) (*Void, error)
}

type inputServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInputServiceClient(cc grpc.ClientConnInterface) InputServiceClient {
	return &inputServiceClient{cc}
}

func (c *inputServiceClient) CreateQuestionInput(ctx context.Context, in *CreateQuestionInputRequest, opts ...grpc.CallOption) (*QuestionInputId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuestionInputId)
	err := c.cc.Invoke(ctx, InputService_CreateQuestionInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputServiceClient) GetQuestionInput(ctx context.Context, in *QuestionInputId, opts ...grpc.CallOption) (*GetQuestionInputResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionInputResponse)
	err := c.cc.Invoke(ctx, InputService_GetQuestionInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputServiceClient) GetAllQuestionInputsByQuestionId(ctx context.Context, in *GetAllQuestionInputsByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllQuestionInputsByQuestionIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllQuestionInputsByQuestionIdResponse)
	err := c.cc.Invoke(ctx, InputService_GetAllQuestionInputsByQuestionId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputServiceClient) UpdateQuestionInput(ctx context.Context, in *UpdateQuestionInputRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, InputService_UpdateQuestionInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputServiceClient) DeleteQuestionInput(ctx context.Context, in *DeleteQuestionInputRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, InputService_DeleteQuestionInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InputServiceServer is the server API for InputService service.
// All implementations must embed UnimplementedInputServiceServer
// for forward compatibility
//
// input
type InputServiceServer interface {
	CreateQuestionInput(context.Context, *CreateQuestionInputRequest) (*QuestionInputId, error)
	GetQuestionInput(context.Context, *QuestionInputId) (*GetQuestionInputResponse, error)
	GetAllQuestionInputsByQuestionId(context.Context, *GetAllQuestionInputsByQuestionIdRequest) (*GetAllQuestionInputsByQuestionIdResponse, error)
	UpdateQuestionInput(context.Context, *UpdateQuestionInputRequest) (*Void, error)
	DeleteQuestionInput(context.Context, *DeleteQuestionInputRequest) (*Void, error)
	mustEmbedUnimplementedInputServiceServer()
}

// UnimplementedInputServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInputServiceServer struct {
}

func (UnimplementedInputServiceServer) CreateQuestionInput(context.Context, *CreateQuestionInputRequest) (*QuestionInputId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestionInput not implemented")
}
func (UnimplementedInputServiceServer) GetQuestionInput(context.Context, *QuestionInputId) (*GetQuestionInputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionInput not implemented")
}
func (UnimplementedInputServiceServer) GetAllQuestionInputsByQuestionId(context.Context, *GetAllQuestionInputsByQuestionIdRequest) (*GetAllQuestionInputsByQuestionIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllQuestionInputsByQuestionId not implemented")
}
func (UnimplementedInputServiceServer) UpdateQuestionInput(context.Context, *UpdateQuestionInputRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQuestionInput not implemented")
}
func (UnimplementedInputServiceServer) DeleteQuestionInput(context.Context, *DeleteQuestionInputRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestionInput not implemented")
}
func (UnimplementedInputServiceServer) mustEmbedUnimplementedInputServiceServer() {}

// UnsafeInputServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InputServiceServer will
// result in compilation errors.
type UnsafeInputServiceServer interface {
	mustEmbedUnimplementedInputServiceServer()
}

func RegisterInputServiceServer(s grpc.ServiceRegistrar, srv InputServiceServer) {
	s.RegisterService(&InputService_ServiceDesc, srv)
}

func _InputService_CreateQuestionInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputServiceServer).CreateQuestionInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InputService_CreateQuestionInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputServiceServer).CreateQuestionInput(ctx, req.(*CreateQuestionInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputService_GetQuestionInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuestionInputId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputServiceServer).GetQuestionInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InputService_GetQuestionInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputServiceServer).GetQuestionInput(ctx, req.(*QuestionInputId))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputService_GetAllQuestionInputsByQuestionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllQuestionInputsByQuestionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputServiceServer).GetAllQuestionInputsByQuestionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InputService_GetAllQuestionInputsByQuestionId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputServiceServer).GetAllQuestionInputsByQuestionId(ctx, req.(*GetAllQuestionInputsByQuestionIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputService_UpdateQuestionInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateQuestionInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputServiceServer).UpdateQuestionInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InputService_UpdateQuestionInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputServiceServer).UpdateQuestionInput(ctx, req.(*UpdateQuestionInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputService_DeleteQuestionInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputServiceServer).DeleteQuestionInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InputService_DeleteQuestionInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputServiceServer).DeleteQuestionInput(ctx, req.(*DeleteQuestionInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InputService_ServiceDesc is the grpc.ServiceDesc for InputService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InputService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "question.InputService",
	HandlerType: (*InputServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQuestionInput",
			Handler:    _InputService_CreateQuestionInput_Handler,
		},
		{
			MethodName: "GetQuestionInput",
			Handler:    _InputService_GetQuestionInput_Handler,
		},
		{
			MethodName: "GetAllQuestionInputsByQuestionId",
			Handler:    _InputService_GetAllQuestionInputsByQuestionId_Handler,
		},
		{
			MethodName: "UpdateQuestionInput",
			Handler:    _InputService_UpdateQuestionInput_Handler,
		},
		{
			MethodName: "DeleteQuestionInput",
			Handler:    _InputService_DeleteQuestionInput_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "question.proto",
}

const (
	TestCaseService_CreateTestCase_FullMethodName              = "/question.TestCaseService/CreateTestCase"
	TestCaseService_GetTestCase_FullMethodName                 = "/question.TestCaseService/GetTestCase"
	TestCaseService_GetAllTestCasesByQuestionId_FullMethodName = "/question.TestCaseService/GetAllTestCasesByQuestionId"
	TestCaseService_UpdateTestCase_FullMethodName              = "/question.TestCaseService/UpdateTestCase"
	TestCaseService_DeleteTestCase_FullMethodName              = "/question.TestCaseService/DeleteTestCase"
)

// TestCaseServiceClient is the client API for TestCaseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// test_case
type TestCaseServiceClient interface {
	CreateTestCase(ctx context.Context, in *CreateTestCaseRequest, opts ...grpc.CallOption) (*TestCaseId, error)
	GetTestCase(ctx context.Context, in *TestCaseId, opts ...grpc.CallOption) (*GetTestCaseResponse, error)
	GetAllTestCasesByQuestionId(ctx context.Context, in *GetAllTestCasesByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllTestCasesByQuestionIdResponse, error)
	UpdateTestCase(ctx context.Context, in *UpdateTestCaseRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteTestCase(ctx context.Context, in *DeleteTestCaseRequest, opts ...grpc.CallOption) (*Void, error)
}

type testCaseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTestCaseServiceClient(cc grpc.ClientConnInterface) TestCaseServiceClient {
	return &testCaseServiceClient{cc}
}

func (c *testCaseServiceClient) CreateTestCase(ctx context.Context, in *CreateTestCaseRequest, opts ...grpc.CallOption) (*TestCaseId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestCaseId)
	err := c.cc.Invoke(ctx, TestCaseService_CreateTestCase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testCaseServiceClient) GetTestCase(ctx context.Context, in *TestCaseId, opts ...grpc.CallOption) (*GetTestCaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTestCaseResponse)
	err := c.cc.Invoke(ctx, TestCaseService_GetTestCase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testCaseServiceClient) GetAllTestCasesByQuestionId(ctx context.Context, in *GetAllTestCasesByQuestionIdRequest, opts ...grpc.CallOption) (*GetAllTestCasesByQuestionIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllTestCasesByQuestionIdResponse)
	err := c.cc.Invoke(ctx, TestCaseService_GetAllTestCasesByQuestionId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testCaseServiceClient) UpdateTestCase(ctx context.Context, in *UpdateTestCaseRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, TestCaseService_UpdateTestCase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testCaseServiceClient) DeleteTestCase(ctx context.Context, in *DeleteTestCaseRequest, opts ...grpc.CallOption) (*Void, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Void)
	err := c.cc.Invoke(ctx, TestCaseService_DeleteTestCase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestCaseServiceServer is the server API for TestCaseService service.
// All implementations must embed UnimplementedTestCaseServiceServer
// for forward compatibility
//
// test_case
type TestCaseServiceServer interface {
	CreateTestCase(context.Context, *CreateTestCaseRequest) (*TestCaseId, error)
	GetTestCase(context.Context, *TestCaseId) (*GetTestCaseResponse, error)
	GetAllTestCasesByQuestionId(context.Context, *GetAllTestCasesByQuestionIdRequest) (*GetAllTestCasesByQuestionIdResponse, error)
	UpdateTestCase(context.Context, *UpdateTestCaseRequest) (*Void, error)
	DeleteTestCase(context.Context, *DeleteTestCaseRequest) (*Void, error)
	mustEmbedUnimplementedTestCaseServiceServer()
}

// UnimplementedTestCaseServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTestCaseServiceServer struct {
}

func (UnimplementedTestCaseServiceServer) CreateTestCase(context.Context, *CreateTestCaseRequest) (*TestCaseId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTestCase not implemented")
}
func (UnimplementedTestCaseServiceServer) GetTestCase(context.Context, *TestCaseId) (*GetTestCaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestCase not implemented")
}
func (UnimplementedTestCaseServiceServer) GetAllTestCasesByQuestionId(context.Context, *GetAllTestCasesByQuestionIdRequest) (*GetAllTestCasesByQuestionIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTestCasesByQuestionId not implemented")
}
func (UnimplementedTestCaseServiceServer) UpdateTestCase(context.Context, *UpdateTestCaseRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTestCase not implemented")
}
func (UnimplementedTestCaseServiceServer) DeleteTestCase(context.Context, *DeleteTestCaseRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTestCase not implemented")
}
func (UnimplementedTestCaseServiceServer) mustEmbedUnimplementedTestCaseServiceServer() {}

// UnsafeTestCaseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestCaseServiceServer will
// result in compilation errors.
type UnsafeTestCaseServiceServer interface {
	mustEmbedUnimplementedTestCaseServiceServer()
}

func RegisterTestCaseServiceServer(s grpc.ServiceRegistrar, srv TestCaseServiceServer) {
	s.RegisterService(&TestCaseService_ServiceDesc, srv)
}

func _TestCaseService_CreateTestCase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTestCaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestCaseServiceServer).CreateTestCase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestCaseService_CreateTestCase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestCaseServiceServer).CreateTestCase(ctx, req.(*CreateTestCaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestCaseService_GetTestCase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestCaseId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestCaseServiceServer).GetTestCase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestCaseService_GetTestCase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestCaseServiceServer).GetTestCase(ctx, req.(*TestCaseId))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestCaseService_GetAllTestCasesByQuestionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllTestCasesByQuestionIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestCaseServiceServer).GetAllTestCasesByQuestionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestCaseService_GetAllTestCasesByQuestionId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestCaseServiceServer).GetAllTestCasesByQuestionId(ctx, req.(*GetAllTestCasesByQuestionIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestCaseService_UpdateTestCase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTestCaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestCaseServiceServer).UpdateTestCase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestCaseService_UpdateTestCase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestCaseServiceServer).UpdateTestCase(ctx, req.(*UpdateTestCaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestCaseService_DeleteTestCase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTestCaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestCaseServiceServer).DeleteTestCase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestCaseService_DeleteTestCase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestCaseServiceServer).DeleteTestCase(ctx, req.(*DeleteTestCaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TestCaseService_ServiceDesc is the grpc.ServiceDesc for TestCaseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TestCaseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "question.TestCaseService",
	HandlerType: (*TestCaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTestCase",
			Handler:    _TestCaseService_CreateTestCase_Handler,
		},
		{
			MethodName: "GetTestCase",
			Handler:    _TestCaseService_GetTestCase_Handler,
		},
		{
			MethodName: "GetAllTestCasesByQuestionId",
			Handler:    _TestCaseService_GetAllTestCasesByQuestionId_Handler,
		},
		{
			MethodName: "UpdateTestCase",
			Handler:    _TestCaseService_UpdateTestCase_Handler,
		},
		{
			MethodName: "DeleteTestCase",
			Handler:    _TestCaseService_DeleteTestCase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "question.proto",
}
